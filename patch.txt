private static void buildHints(String basePtr, JavaType jt, TypeHints hints,
                               ObjectMapper mapper, SerializationConfig cfg, Set<JavaType> seen) {
    if (jt == null) return;
    jt = unwrapOptionals(jt, mapper);
    if (jt == null || seen.contains(jt)) return;
    seen.add(jt);

    // ✅ 0) Enums are leaf types: record and stop
    if (jt.isEnumType() || jt.getRawClass().isEnum()) {
        // Note: the parent already recorded the property path → jt when it discovered the field,
        // so for non-root cases you don't need to put() again here. It's harmless to be explicit:
        if (!basePtr.isEmpty()) hints.put(basePtr, jt);
        return;
    }

    // 1) Containers
    if (jt.isContainerType()) {
        if (jt.isCollectionLikeType()) {
            JavaType elem = unwrapOptionals(jt.getContentType(), mapper);
            String elemPtr = basePtr + "/*";
            hints.put(elemPtr, elem);
            buildHints(elemPtr, elem, hints, mapper, cfg, seen);
            return;
        } else if (jt.isMapLikeType()) {
            JavaType val = unwrapOptionals(jt.getContentType(), mapper);
            String valPtr = basePtr + "/*";
            hints.put(valPtr, val);
            buildHints(valPtr, val, hints, mapper, cfg, seen);
            return;
        }
    }

    if (jt.isJavaLangObject()) return;

    // 2) Bean properties
    BeanDescription bd = cfg.introspect(jt);
    List<BeanPropertyDefinition> props = bd.findProperties();
    boolean gotAny = false;
    for (BeanPropertyDefinition prop : props) {
        String name = prop.getName();
        JavaType pt = unwrapOptionals(prop.getPrimaryType(), mapper);
        if (pt == null) continue;
        gotAny = true;
        String ptr = basePtr + "/" + escape(name);
        hints.put(ptr, pt);
        buildHints(ptr, pt, hints, mapper, cfg, seen);
    }

    // 3) Immutable interfaces fallback (but NOT for enums)
    if (!gotAny && jt.isInterface()) {
        collectInterfaceAccessors(jt.getRawClass(), mapper).forEach((propName, propType) -> {
            JavaType un = unwrapOptionals(propType, mapper);
            if (un == null) return;
            String ptr = basePtr + "/" + escape(propName);
            hints.put(ptr, un);
            buildHints(ptr, un, hints, mapper, cfg, seen);
        });
    }
}


private static JavaType resolveTypeWithWildcards(JsonPointer fullPath, TypeHints hints, int baseDepth) {
    String[] segs = splitPointer(fullPath);
    if (segs.length == 0) return null;
    int start = Math.min(baseDepth, segs.length);
    String[] tail = Arrays.copyOfRange(segs, start, segs.length);
    if (tail.length == 0) return null;

    // 1) Exact match first
    JavaType t = hints.resolveExact(JsonPointer.compile(toPointerString(tail)));
    if (t != null) return t;

    // 2) Wildcard pattern match against all hint keys ( '*' matches exactly one segment )
    JavaType best = null;
    int bestScore = -1; // higher = more specific (fewer '*')
    for (Map.Entry<String, JavaType> e : hints.entries()) {
        String ptr = e.getKey();
        String[] pat = splitPointer(JsonPointer.compile(ptr));
        if (pat.length != tail.length) continue;

        boolean ok = true;
        int exactCount = 0;
        for (int i = 0; i < pat.length; i++) {
            if ("*".equals(pat[i])) continue;
            if (!pat[i].equals(tail[i])) { ok = false; break; }
            exactCount++;
        }
        if (!ok) continue;

        if (exactCount > bestScore) {
            bestScore = exactCount;
            best = e.getValue();
            if (bestScore == pat.length) break; // perfect exact match
        }
    }
    return best;
}

public static final class StringEquivalences {
  private StringEquivalences() {}

  /** Equal if, after NFKC + whitespace collapse + mapping ANY non-ASCII or punctuation/symbol to '?', both sides match. */
  public static java.util.function.BiPredicate<com.fasterxml.jackson.databind.JsonNode, com.fasterxml.jackson.databind.JsonNode>
  punctuationQuestionEquals() {
    return unicodeLossyQuestionEquals(); // keep old name wired to the new behavior
  }

  /** New explicit name if you want to call it directly. */
  public static java.util.function.BiPredicate<com.fasterxml.jackson.databind.JsonNode, com.fasterxml.jackson.databind.JsonNode>
  unicodeLossyQuestionEquals() {
    return (a, b) -> {
      if (a == null || b == null || !a.isTextual() || !b.isTextual()) return false;

      String sa = normalize(a.asText());
      String sb = normalize(b.asText());

      Template ta = toLossyAsciiTemplate(sa);
      Template tb = toLossyAsciiTemplate(sb);

      // Only treat as equivalent if at least one side had lossy replacement or already contained '?'
      boolean anyLossy = ta.changed || tb.changed || sa.indexOf('?') >= 0 || sb.indexOf('?') >= 0;
      return anyLossy && ta.value.equals(tb.value);
    };
  }

  // ---------- helpers ----------

  private static String normalize(String s) {
    // Unicode NFKC + collapse whitespace to single spaces and trim
    s = java.text.Normalizer.normalize(s, java.text.Normalizer.Form.NFKC);
    return s.trim().replaceAll("\\s+", " ");
  }

  /** Result holder: the templated string + whether any char was replaced. */
  private static final class Template {
    final String value; final boolean changed;
    Template(String v, boolean c) { this.value = v; this.changed = c; }
  }

  /**
   * Create a lossy ASCII template:
   *  - Keep ASCII letters [A-Za-z], digits [0-9], and space ' ' as-is.
   *  - Map EVERYTHING else (non-ASCII, punctuation, symbols, control chars) to '?'.
   *  This mirrors what many encoders do when they can't represent a code point.
   */
  private static Template toLossyAsciiTemplate(String s) {
    StringBuilder out = new StringBuilder(s.length());
    boolean changed = false;
    for (int i = 0; i < s.length(); ) {
      int cp = s.codePointAt(i);
      boolean keep =
          cp < 128 && ( // ASCII only
              (cp >= 'A' && cp <= 'Z') ||
              (cp >= 'a' && cp <= 'z') ||
              (cp >= '0' && cp <= '9') ||
              cp == ' ' // single spaces only; we already collapsed whitespace
          );
      if (keep) {
        out.append((char) cp);
      } else {
        out.append('?');
        // mark changed if this was not already '?'
        if (cp != '?') changed = true;
      }
      i += Character.charCount(cp);
    }
    return new Template(out.toString(), changed);
  }
}

